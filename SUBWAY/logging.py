import logging
import pickle
import datetime
import uuid

logging.basicConfig(filename='events.log', level=logging.DEBUG, format='%(asctime)s %(message)s')

class BankAccount:
    def __init__(self, user, balance=0):
        self.user = user
        self.balance = balance
        logging.info(f"BankAccount object created for user {user} with initial balance {balance}")

    def deposit(self, amount):
        self.balance += amount
        logging.info(f"Deposit of {amount} made by user {self.user}. New balance: {self.balance}")

    def withdraw(self, amount):
        if self.balance >= amount:
            self.balance -= amount
            logging.info(f"Withdrawal of {amount} made by user {self.user}. New balance: {self.balance}")
            return amount
        else:
            logging.error(f"Withdrawal failed for user {self.user}. Insufficient balance.")
            raise Exception("Insufficient balance.")


class Passenger:
    def __init__(self, name, bank_account):
        self.name = name
        self.id = self.generate_id()
        self.bank_account = bank_account
        self.id = uuid.uuid4().hex # A unique ID generated by the program
        logging.info(f"Passenger object created for user {name} with ID {self.id} and bank account {bank_account}")

    def generate_id(self):
        return hashlib.sha256(str(datetime.datetime.now().timestamp()).encode()).hexdigest()

    def show_id(self):
        print(f"Your unique ID is: {self.id}")
        logging.info(f"Showing ID for user {self.name}. ID: {self.id}")

    def create_passenger(name):
        bank_account = BankAccount(name)
        passenger = Passenger(name, bank_account)
        with open("users.pickle", "ab") as f:
            pickle.dump(passenger, f)
        logging.info(f"Passenger created successfully for user {name} with ID {passenger.id} and bank account {bank_account}")
        print("Passenger created successfully!")
        passenger.show_id()
        return passenger

class MetroCard:
    def __init__(self, user, balance=0):
        self.user = user
        self.balance = balance
        logging.info(f"MetroCard object created for user {user} with initial balance {balance}")

    def charge(self, amount):
        self.balance += amount
        logging.info(f"Charge of {amount} made to user {self.user}'s MetroCard. New balance: {self.balance}")

    def deduct(self, amount):
        self.balance -= amount
        logging.info(f"Deduction of {amount} made from user {self.user}'s MetroCard. New balance: {self.balance}")
# logging.basicConfig(filename='metro_card.log', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
class Trip:
    def __init__(self, fare, start_time, end_time):
        self.fare = fare
        self.start_time = start_time
        self.end_time = end_time
        self.is_active = True

    def deactivate(self):
        self.is_active = False

class MetroCard:
    def __init__(self, user):
        self.balance = 0
        self.user = user
        self.id = uuid.uuid1()

    def deduct(self, fare):
        self.balance -= fare

class SingleTable(MetroCard):
    def __init__(self, user):
        super().__init__(user)
        self.is_used = False

    def use(self, fare, start_time, end_time):
        if not self.is_used:
            self.is_used = True
            trip = Trip(fare, start_time, end_time)
            logging.info(f"SingleTable card used by {self.user} with id {self.id} at fare {fare} from {start_time} to {end_time}")
            return trip
        else:
            logging.error(f"SingleTable card with id {self.id} has already been used.")
            raise Exception("This card has already been used.")

class Credit(MetroCard):
    def use(self, fare, start_time, end_time):
        if self.balance >= fare:
            self.deduct(fare)
            trip = Trip(fare, start_time, end_time)
            logging.info(f"Credit card used by {self.user} with id {self.id} at fare {fare} from {start_time} to {end_time}")
            return trip
        else:
            logging.error(f"Insufficient balance for Credit card with id {self.id} used by {self.user}")
            raise Exception("Insufficient balance.")

#Here, logging.info, logging.error functions are used to log successful trips and error events respectively.

class Trip:
    def __init__(self, fare, start_time, end_time):
        self.fare = fare
        self.start_time = start_time
        self.end_time = end_time

class MetroCard:
    def __init__(self, user):
        self.user = user
        self.balance = 0

    def deduct(self, fare):
        self.balance -= fare

class Term(MetroCard):
    def __init__(self, user, expiry_date):
        super().__init__(user)
        self.expiry_date = expiry_date

    def use(self, fare, start_time, end_time):
        if self.expiry_date > datetime.datetime.now().date():
            if self.balance >= fare:
                self.deduct(fare)
                logging.info("Successful trip with fare: %d, start time: %s, end time: %s", fare, start_time, end_time)
                return Trip(fare, start_time, end_time)
            else:
                logging.error("Insufficient balance.")
                raise Exception("Insufficient balance.")
        else:
            logging.error("This card has expired.")
            raise Exception("This card has expired.")